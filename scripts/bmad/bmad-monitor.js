/**
 * @ai-context BMAD Project Monitor
 * @ai-invariant Generates DASHBOARD.md based on current project state
 */
const fs = require('fs');
const path = require('path');

class BMADMonitor {
    constructor() {
        this.rootDir = process.cwd();
        this.docsDir = path.join(this.rootDir, 'docs');
        this.githubDir = path.join(this.rootDir, '.github');
        this.dashboardFile = path.join(this.docsDir, 'DASHBOARD.md');
    }

    async generateDashboard() {
        console.log('üìä Generating Project Dashboard...');

        const workflowStats = this.getWorkflowStats();
        const qaStats = this.getQAStats();
        const docStats = this.getDocStats();
        const taskStats = this.getTaskStats();

        const dashboardContent = `
# üìä BMAD Project Dashboard

**Last Updated:** ${new Date().toLocaleString()}

## üö¶ Project Health
- **Active Workflows:** ${workflowStats.active}
- **Completed Workflows:** ${workflowStats.completed}
- **Documentation Coverage:** ${docStats.coverage}%
- **Test Status:** ${qaStats.status}

## üîÑ Workflow Status
${workflowStats.details}

## üß™ QA & Testing
- **Last QA Report:** ${qaStats.lastReport}
- **Test Coverage:** ${qaStats.coverage}

## üìö Documentation
- **Architecture Docs:** ${docStats.architecture ? '‚úÖ' : '‚ùå'}
- **API Docs:** ${docStats.api ? '‚úÖ' : '‚ùå'}
- **System Map:** ${docStats.systemMap ? '‚úÖ' : '‚ùå'}

## üìù Task Progress
${taskStats.summary}

---
*Generated by BMAD Monitor*
`;

        if (!fs.existsSync(this.docsDir)) {
            fs.mkdirSync(this.docsDir, { recursive: true });
        }

        fs.writeFileSync(this.dashboardFile, dashboardContent);
        console.log(`‚úÖ Dashboard generated at ${this.dashboardFile}`);
    }

    getWorkflowStats() {
        let active = 0;
        let completed = 0;
        let details = '';

        if (fs.existsSync(this.githubDir)) {
            const files = fs.readdirSync(this.githubDir).filter(f => f.startsWith('workflow-state-') && f.endsWith('.json'));

            files.forEach(file => {
                try {
                    const content = JSON.parse(fs.readFileSync(path.join(this.githubDir, file), 'utf-8'));
                    const status = content.status || 'unknown';
                    const id = content.workflowId || 'N/A';

                    if (status === 'running') active++;
                    else if (status === 'completed') completed++;

                    details += `- **ID:** \`${id}\` | **Status:** ${status} | **Phase:** ${content.phase || 'N/A'}\n`;
                } catch (e) {
                    console.error(`Error reading ${file}:`, e.message);
                }
            });
        }

        if (!details) details = '_No active or archived workflows found._';

        return { active, completed, details };
    }

    getQAStats() {
        // Placeholder logic - ideally parses JUnit XML or coverage reports
        return {
            status: 'Unknown',
            lastReport: 'N/A',
            coverage: 'N/A'
        };
    }

    getDocStats() {
        const archDir = path.join(this.docsDir, 'architecture');
        const exists = file => fs.existsSync(path.join(archDir, file));

        return {
            coverage: exists('SYSTEM_MAP.md') ? 100 : 0, // Simplified metric
            architecture: exists('ARCHITECTURE.md'),
            api: exists('API.md'),
            systemMap: exists('SYSTEM_MAP.md')
        };
    }

    getTaskStats() {
        // Try to read task.md from root or artifacts (if we knew the path, but here we stick to repo)
        const taskFile = path.join(this.rootDir, 'task.md');
        if (fs.existsSync(taskFile)) {
            const content = fs.readFileSync(taskFile, 'utf-8');
            const total = (content.match(/- \[ \]/g) || []).length + (content.match(/- \[x\]/g) || []).length;
            const completed = (content.match(/- \[x\]/g) || []).length;
            const percent = total > 0 ? Math.round((completed / total) * 100) : 0;

            return {
                summary: `- **Progress:** ${percent}% (${completed}/${total} tasks)`
            };
        }
        return { summary: '_No task.md found in project root._' };
    }

    /**
     * @ai-context Monitor CI status and trigger recovery if needed
     */
    async monitorCI() {
        console.log('üïµÔ∏è Monitoring CI Status...');
        try {
            const RecoveryPersona = require('../../personas/recovery');
            // Ensure we have a token
            const token = process.env.GITHUB_TOKEN;
            if (!token) {
                console.warn('‚ö†Ô∏è No GITHUB_TOKEN found. Skipping automated CI monitoring.');
                return;
            }

            const recovery = new RecoveryPersona(token);
            // We pass a dummy issue number or 0 for global monitoring, 
            // but RecoveryPersona.execute expects an issueNumber for reporting.
            // We'll use 0 or a dedicated "System" issue if possible, or let it create one.
            // For now, let's assume issue #0 is for system alerts.
            const result = await recovery.execute(0);

            if (result.ciStatus && result.ciStatus.failed) {
                console.log('üö® CI Failure detected and Recovery triggered!');
            } else {
                console.log('‚úÖ CI Status is healthy.');
            }
        } catch (error) {
            console.error(`‚ùå Error in CI Monitoring: ${error.message}`);
        }
    }
}

if (require.main === module) {
    const monitor = new BMADMonitor();
    monitor.generateDashboard();
    // Also run CI monitor if flag is present
    if (process.argv.includes('--monitor-ci')) {
        monitor.monitorCI();
    }
}

module.exports = BMADMonitor;
