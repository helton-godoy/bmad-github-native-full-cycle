/**
 * @ai-context Project Manager Persona - Planning and requirements definition
 * @ai-invariant PM must analyze requirements and create work plans
 * @ai-connection PM connects to GitHub Issues and creates structured work items
 */
const BasePersona = require('./base-persona-enhanced');

class ProjectManager extends BasePersona {
    constructor(githubToken) {
        super('PM Agent', 'PM', githubToken);
    }

    /**
     * @ai-context Analyze GitHub issue and create work plan
     */
    async execute(issueNumber) {
        this.log('Starting issue analysis');

        try {
            const issueData = await this.getIssue(issueNumber);

            // SECURITY: Sanitize input to prevent prompt injection
            issueData.body = this.sanitizeInput(issueData.body);
            issueData.title = this.sanitizeInput(issueData.title);

            this.log(`Analyzing issue: ${issueData.title}`);

            // Create work plan
            const workPlan = this.createWorkPlan(issueData);

            // Update context
            this.updateActiveContext(`Analisando issue #${issueNumber}: "${issueData.title}"`);

            // Create planning issue for architecture
            await this.createArchitecturePlanningIssue(issueData, workPlan);

            // Micro-commit the analysis
            await this.microCommit('PM: Issue analysis completed', [
                {
                    path: 'docs/planning/work-plan.md',
                    content: workPlan
                }
            ]);

            this.log('Issue analysis completed');
            return workPlan;

        } catch (error) {
            this.log(`Error in PM execution: ${error.message}`);
            throw error;
        }
    }

    /**
     * @ai-context Create structured work plan from issue
     */
    createWorkPlan(issue) {
        const plan = `# Work Plan - ${issue.title}

## Issue Analysis
- **Number**: #${issue.number}
- **Title**: ${issue.title}
- **Created**: ${issue.created_at}
- **Assignee**: ${issue.assignee?.login || 'Unassigned'}

## Requirements
${issue.body}

## Work Breakdown
1. **Architecture Design** - Define technical approach
2. **Implementation** - Develop solution
3. **Testing** - QA validation
4. **Security Review** - Security compliance
5. **Deployment** - DevOps preparation
6. **Release** - Version management

## Success Criteria
- [ ] Requirements clearly defined
- [ ] Technical approach approved
- [ ] Implementation completed
- [ ] Tests passing
- [ ] Security approved
- [ ] Deployed successfully

## Timeline
- **Start**: ${new Date().toISOString()}
- **Architecture**: 1-2 hours
- **Implementation**: 4-8 hours
- **Testing**: 2-4 hours
- **Deployment**: 1-2 hours

## Dependencies
- GitHub API access
- Required permissions
- External services (if any)

---
*Generated by PM Agent on ${new Date().toISOString()}*`;

        return plan;
    }

    /**
     * @ai-context Create architecture planning issue
     */
    async createArchitecturePlanningIssue(originalIssue, workPlan) {
        const title = `Architecture Planning: ${originalIssue.title}`;
        const body = `## Original Issue
#${originalIssue.number}: ${originalIssue.title}

## Work Plan
${workPlan}

## Architecture Tasks
1. **Technical Requirements Analysis**
2. **System Design**
3. **API Design (if needed)**
4. **Database Schema (if needed)**
5. **Security Considerations**
6. **Performance Requirements**

## Deliverables
- Architecture document
- Technical specifications
- Implementation roadmap

## Next Steps
@helton-godoy/architect Please review and provide architecture design.

---
*Created by PM Agent*`;

        await this.createIssue(title, body, ['architecture', 'planning']);
    }

    /**
     * @ai-context Sanitize input to prevent prompt injection
     */
    sanitizeInput(text) {
        if (!text) return '';

        // Remove dangerous instructions
        const dangerousPatterns = [
            /ignore (all )?previous instructions/gi,
            /system override/gi,
            /delete (all )?files/gi,
            /rm -rf/gi,
            /sudo /gi,
            /<script>/gi
        ];

        let sanitized = text;
        for (const pattern of dangerousPatterns) {
            sanitized = sanitized.replace(pattern, '[REDACTED_SECURITY]');
        }

        return sanitized;
    }
}

module.exports = ProjectManager;
